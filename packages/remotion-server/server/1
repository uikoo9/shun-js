require('dotenv').config();
const { renderVideo } = require('./renderer');
const { uploadToR2 } = require('./uploader');
const fs = require('fs');
const path = require('path');

// 配置
const CONFIG = {
  POLL_INTERVAL: 60 * 1000, // 60秒检查一次
  MAX_CONCURRENT: 1, // 同时只渲染1个视频
  OUTPUT_DIR: path.join(__dirname, 'output'),
};

// 确保输出目录存在
if (!fs.existsSync(CONFIG.OUTPUT_DIR)) {
  fs.mkdirSync(CONFIG.OUTPUT_DIR, { recursive: true });
}

let isProcessing = false;

/**
 * 更新作品状态
 */
async function updateWorkStatus(workId, status, updates = {}) {
  try {
    const { error } = await supabase
      .from('works')
      .update({
        status,
        updated_at: new Date().toISOString(),
        ...updates,
      })
      .eq('id', workId);

    if (error) {
      console.error(`Error updating work ${workId} to ${status}:`, error);
    }
  } catch (error) {
    console.error('Unexpected error updating work status:', error);
  }
}

/**
 * 处理单个作品的渲染
 */
async function processWork(work) {
  const workId = work.id;
  const outputPath = path.join(CONFIG.OUTPUT_DIR, `${workId}.mp4`);

  console.log(`\n[${new Date().toISOString()}] Processing work: ${workId}`);
  console.log(`Title: ${work.title}`);

  try {
    // 1. 更新状态为 rendering
    await updateWorkStatus(workId, 'rendering', {
      render_started_at: new Date().toISOString(),
    });

    // 2. 渲染视频
    console.log('Rendering video...');
    await renderVideo({
      sourceCode: work.source_code,
      outputPath,
      width: work.width || 1920,
      height: work.height || 1080,
      fps: work.fps || 30,
    });

    console.log('Video rendered successfully');

    // 3. 上传到 R2
    console.log('Uploading to R2...');
    const videoUrl = await uploadToR2({
      filePath: outputPath,
      workId: workId,
    });

    console.log('Video uploaded:', videoUrl);

    // 4. 获取视频信息
    const stats = fs.statSync(outputPath);
    const durationInFrames = Math.round(5 * (work.fps || 30)); // 暂时硬编码为5秒

    // 5. 更新数据库
    await updateWorkStatus(workId, 'published', {
      video_url: videoUrl,
      render_completed_at: new Date().toISOString(),
      published_at: new Date().toISOString(),
      duration_in_frames: durationInFrames,
      duration_seconds: durationInFrames / (work.fps || 30),
    });

    console.log(`✅ Work ${workId} completed successfully`);

    // 6. 清理本地文件
    fs.unlinkSync(outputPath);
  } catch (error) {
    console.error(`❌ Error processing work ${workId}:`, error);

    // 更新为失败状态
    await updateWorkStatus(workId, 'render_failed', {
      render_error: error.message,
      render_completed_at: new Date().toISOString(),
    });

    // 清理可能存在的文件
    if (fs.existsSync(outputPath)) {
      fs.unlinkSync(outputPath);
    }
  }
}

/**
 * 主处理循环
 */
async function processQueue() {
  if (isProcessing) {
    console.log('Already processing, skipping...');
    return;
  }

  isProcessing = true;

  try {
    const works = await fetchPendingWorks();

    if (works.length === 0) {
      console.log(`[${new Date().toISOString()}] No pending works`);
    } else {
      console.log(`[${new Date().toISOString()}] Found ${works.length} pending work(s)`);

      for (const work of works) {
        await processWork(work);
      }
    }
  } catch (error) {
    console.error('Error in process queue:', error);
  } finally {
    isProcessing = false;
  }
}

/**
 * 启动 Worker
 */
async function start() {
  console.log('='.repeat(60));
  console.log('Remotion Render Worker Started');
  console.log('='.repeat(60));
  console.log(`Poll Interval: ${CONFIG.POLL_INTERVAL / 1000}s`);
  console.log(`Max Concurrent: ${CONFIG.MAX_CONCURRENT}`);
  console.log(`Output Directory: ${CONFIG.OUTPUT_DIR}`);
  console.log('='.repeat(60));

  // 立即执行一次
  await processQueue();

  // 定期执行
  setInterval(processQueue, CONFIG.POLL_INTERVAL);
}

// 优雅退出
process.on('SIGINT', () => {
  console.log('\nReceived SIGINT, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nReceived SIGTERM, shutting down gracefully...');
  process.exit(0);
});

// 启动
start().catch((error) => {
  console.error('Failed to start worker:', error);
  process.exit(1);
});
